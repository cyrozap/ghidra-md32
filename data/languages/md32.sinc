define endian=big;
define alignment=2;

define space PMEM type=ram_space size=4 default;
define space DMEM type=ram_space size=4;
define space register type=register_space size=4;

define register offset=0 size=4 [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
];

define register offset=0x100 size=4 [
	sr ipc isr
	lf
	ls0 le0 lc0
	ls1 le1 lc1
	ls2 le2 lc2
	dbg
];

define register offset=0x200 size=4 [
	a0l a0h
];

define register offset=0x200 size=8 [
	a0
];

define register offset=0x1000 size=4 pc;

define register offset=0x2000 size=4 contextreg;

define context contextreg
	bundle = (0, 0) noflow

	# Instruction decoding phase.
	phase = (1, 1)

	# Indicate that this is the last instruction in a loop.
	end_of_loop = (2, 2) noflow
;

define token instr32(32)
	op_31_25 = (25, 31)
	op_31_24 = (24, 31)
	op_31_23 = (23, 31)
	op_31_22 = (22, 31)
	op_31_21 = (21, 31)
	op_31_20 = (20, 31)
	op_31_19 = (19, 31)
	op_31_18 = (18, 31)
	op_31_17 = (17, 31)
	op_31_16 = (16, 31)
	op_31_13 = (13, 31)
	op_31_12 = (12, 31)
	op_31_8 = (8, 31)
	op_31_4 = (4, 31)
	op_31_0 = (0, 31)
	op_15_13 = (13, 15)
	op_8_8 = (8, 8)
	imm_23_8 = (8, 23)
	imm_21_18 = (18, 21)
	imm_21_17 = (17, 21)
	imm_19_8 = (8, 19)
	imm_18_14 = (14, 18)
	imm_18_9 = (9, 18)
	imm_17_13 = (13, 17)
	imm_16_12 = (12, 16)
	imm_15_0 = (0, 15)
	imm_12_12 = (12, 12)
	imm_13_9 = (9, 13)
	imm_12_8 = (8, 12)
	imm_11_4 = (4, 11)
	imm32_7_0 = (0, 7)
	imm_4_0 = (0, 4)
	simm_24_4 = (4, 24) signed
	simm_23_8 = (8, 23) signed
	simm_22_8 = (8, 22) signed
	simm_21_18 = (18, 21) signed
	simm_20_0 = (0, 20) signed
	simm_19_8 = (8, 19) signed
	simm_17_9 = (9, 17) signed
	r_8_5 = (5, 8)
	rs2 = (8, 11)
	csrs1 = (4, 7)
	rs1 = (4, 7)
	csrd = (0, 3)
	rd = (0, 3)
;

define token instr16(16)
	op_15_15 = (15, 15)
	op_15_11 = (11, 15)
	op_15_10 = (10, 15)
	op_15_9 = (9, 15)
	op_15_8 = (8, 15)
	op_15_7 = (7, 15)
	op_15_6 = (6, 15)
	op_15_4 = (4, 15)
	op_15_3 = (3, 15)
	op_15_0 = (0, 15)
	op_14_10 = (10, 14)
	op_14_9 = (9, 14)
	op_14_8 = (8, 14)
	op_14_7 = (7, 14)
	op_14_6 = (6, 14)
	op_14_4 = (4, 14)
	op_14_0 = (0, 14)
	op_8_6 = (6, 8)
	imm_9_7 = (7, 9)
	imm_9_6 = (6, 9)
	imm_9_4 = (4, 9)
	imm_8_6 = (6, 8)
	imm_8_4 = (4, 8)
	imm_8_3 = (3, 8)
	imm_7_4 = (4, 7)
	imm_7_0 = (0, 7)
	imm_6_6 = (6, 6)
	imm_6_3 = (3, 6)
	simm_10_4 = (4, 10) signed
	simm_9_7 = (7, 9) signed
	simm_8_6 = (6, 8) signed
	simm_8_4 = (4, 8) signed
	simm_6_0 = (0, 6) signed
	rm_r1_r8_8_6 = (6, 8)
	rm = (4, 7)
	rm_r1_r8_6_4 = (4, 6)
	csrm_6_3 = (3, 6)
	rm_6_3 = (3, 6)
	rm_r1_r8_5_3 = (3, 5)
	csrn = (0, 3)
	rn = (0, 3)
	rn_even = (0, 2)
	rn_odd = (0, 2)
	rn_r1_r8 = (0, 2)
;

attach variables [ rd rs1 rs2 r_8_5 rn rm rm_6_3 ] [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
];

attach variables [ rn_r1_r8 rm_r1_r8_5_3 rm_r1_r8_6_4 rm_r1_r8_8_6 ] [
	r1 r2 r3 r4 r5 r6 r7 r8
];

attach variables [ rn_even ] [
	r0 r2 r4 r6 r8 r10 r12 r14
];

attach variables [ rn_odd ] [
	r1 r3 r5 r7 r9 r11 r13 r15
];

attach variables [ csrd csrs1 csrn csrm_6_3 ] [
	sr ipc isr _ lf ls0 le0 lc0 ls1 le1 lc1 ls2 le2 lc2 _ _
];


define pcodeop halt;
define pcodeop ieon;
define pcodeop ieoff;
define pcodeop ior;
define pcodeop iow;
define pcodeop swi;


:^instruction is phase=0 & instruction [ phase = 1; ] {
	build instruction;
}

:^instruction is phase=0 & end_of_loop=1 & instruction [ phase = 1; ] {
	build instruction;
	if (lc0 == 1) goto <end_loop>;
	lc0 = lc0 - 1;
	goto [ls0];
	<end_loop>
}

with: phase=1 {


# 32-bit instructions

with: bundle=0 {

# Move signed immediate to register.
:mv rd, #simm_24_4 is op_31_25=0 & simm_24_4 & rd {
	rd = simm_24_4;
}

:add rd, rs1, rs2 is op_31_12=0x0400e & rs2 & rs1 & rd {
	rd = rs1 + rs2;
}

:sub rd, rs1, rs2 is op_31_12=0x0401e & rs2 & rs1 & rd {
	rd = rs1 - rs2;
}

# Add with carry.
# TODO: Implement carry.
:addx rd, rs1, rs2 is op_31_12=0x0402e & rs2 & rs1 & rd {
	rd = rs1 + rs2;
}

# Subtract with borrow.
# TODO: Implement borrow.
:subx rd, rs1, rs2 is op_31_12=0x0403e & rs2 & rs1 & rd {
	rd = rs1 - rs2;
}

:and rd, rs1, rs2 is op_31_12=0x0404e & rs2 & rs1 & rd {
	rd = rs1 & rs2;
}

:or rd, rs1, rs2 is op_31_12=0x0405e & rs2 & rs1 & rd {
	rd = rs1 | rs2;
}

:xor rd, rs1, rs2 is op_31_12=0x0406e & rs2 & rs1 & rd {
	rd = rs1 ^ rs2;
}

# Conditional inversion.
:cinv rd, rs1, rs2 is op_31_12=0x0407e & rs2 & rs1 & rd {
	# If rs1 is positive, rd=rs2.
	if (rs1 s< 0) goto <negative>;
	rd = rs2;
	goto <end>;
	<negative>
	# If rs1 is negative, rd=-rs2.
	rd = -rs2;
	<end>
}

:xtd rd, rs1, rs2 is op_31_12=0x0408e & rs2 & rs1 & rd unimpl

:sll rd, rs1, rs2 is op_31_12=0x0409e & rs2 & rs1 & rd {
	rd = rs1 << rs2;
}

:sra rd, rs1, rs2 is op_31_12=0x040ae & rs2 & rs1 & rd {
	rd = rs1 s>> rs2;
}

:srl rd, rs1, rs2 is op_31_12=0x040be & rs2 & rs1 & rd {
	rd = rs1 >> rs2;
}

:mul rd, rs1, rs2 is op_31_12=0x040ce & rs2 & rs1 & rd {
	rd = rs1 * rs2;
}

# Unsigned division.
:udiv rd, rs2 is op_31_12=0x040dc & rs2 & rd {
	a0l = rd / rs2;
	a0h = rd % rs2;
}

# Also unsigned division. Maybe the u/s are for unsaturating/saturating?
# TODO: Find out how sdiv differs from udiv.
:sdiv rd, rs2 is op_31_12=0x040dd & rs2 & rd {
	a0l = rd / rs2;
	a0h = rd % rs2;
}

# Move from registers to accumulator(?).
:mv a0, rs1, rs2 is op_31_12=0x0412c & rs2 & rs1 & a0 {
	a0l = rs1;
	a0h = rs2;
}

# Move from register to accumulator(?) low.
:mv a0l, rs1 is op_31_12=0x04134 & rs1 & a0l {
	a0l = rs1;
}

# Move from register to accumulator(?) high.
:mv a0h, rs2 is op_31_12=0x04148 & rs2 & a0h {
	a0h = rs2;
}

# Move from CSR to register.
:mv rd, csrs1 is op_31_12=0x04154 & csrs1 & rd {
	rd = csrs1;
}

# Move from accumulator(?) high to register.
:mv rd, a0h is op_31_12=0x04162 & rd & a0h {
	rd = a0h;
}

# Move from accumulator(?) low to register.
:mv rd, a0l is op_31_12=0x04172 & rd & a0l {
	rd = a0l;
}

# Move from register to CSR.
:mv csrd, rs1 is op_31_12=0x04182 & rs1 & csrd {
	csrd = rs1;
}

# Count leading bits. Starting from the most significant bit in rs1, count the
# number of contiguous bits that match the most significant bit and store that
# count in rd.
:clb rd, rs1 is op_31_12=0x04196 & rs1 & rd {
	local tmp = rs1;
	if (tmp & (1 << 31)) == 0 goto <skip_inversion>;
	tmp = ~rs1;
	<skip_inversion>
	rd = 1;
	if (tmp & (1 << 30)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 29)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 28)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 27)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 26)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 25)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 24)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 23)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 22)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 21)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 20)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 19)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 18)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 17)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 16)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 15)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 14)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 13)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 12)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 11)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 10)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 9)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 8)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 7)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 6)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 5)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 4)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 3)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 2)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 1)) != 0 goto inst_next;
	rd = rd + 1;
	if (tmp & (1 << 0)) != 0 goto inst_next;
	rd = rd + 1;
}

:xtd rd, rs1, #imm_12_8 is op_31_13=0b0000010000011011011 & imm_12_8 & rs1 & rd unimpl

# Shift register right (logical) by an immediate.
:srl rd, rs1, #imm_12_8 is op_31_13=0b0000010000011100011 & imm_12_8 & rs1 & rd {
	rd = rs1 >> imm_12_8;
}

# Shift register right (arithmetic) by an immediate.
:sra rd, rs1, #imm_12_8 is op_31_13=0b0000010000011101011 & imm_12_8 & rs1 & rd {
	rd = rs1 s>> imm_12_8;
}

# Shift register left (logical) by an immediate.
:sll rd, rs1, #imm_12_8 is op_31_13=0b0000010000011110011 & imm_12_8 & rs1 & rd {
	rd = rs1 << imm_12_8;
}

# Couldn't get these to work in hardware.
# TODO: Find hardware that supports these instructions and test them.
:bset rd, rs1, rs2 is op_31_12=0x04880 & rs2 & rs1 & rd unimpl
:bclr rd, rs1, rs2 is op_31_12=0x04882 & rs2 & rs1 & rd unimpl
:btgl rd, rs1, rs2 is op_31_12=0x04884 & rs2 & rs1 & rd unimpl
:btst rd, rs1, rs2 is op_31_12=0x04886 & rs2 & rs1 & rd unimpl

# Couldn't get these to work in hardware.
# TODO: Find hardware that supports these instructions and test them.
:bset rd, rs1, #imm_12_8 is op_31_13=0b0000010010001001100 & imm_12_8 & rs1 & rd unimpl
:bclr rd, rs1, #imm_12_8 is op_31_13=0b0000010010001001101 & imm_12_8 & rs1 & rd unimpl
:btgl rd, rs1, #imm_12_8 is op_31_13=0b0000010010001001110 & imm_12_8 & rs1 & rd unimpl
:btst rd, rs1, #imm_12_8 is op_31_13=0b0000010010001001111 & imm_12_8 & rs1 & rd unimpl

# Couldn't get these to work in hardware.
# TODO: Find hardware that supports these instructions and test them.
:ror rd, rs1, rs2 is op_31_12=0x048c2 & rs2 & rs1 & rd unimpl
:rol rd, rs1, rs2 is op_31_12=0x048c3 & rs2 & rs1 & rd unimpl

# 32-bit NOP.
:nop is op_31_0=0x05000000 {}

:brk is op_31_0=0x05400000 unimpl
:brk.j is op_31_0=0x05600000 unimpl

# Halt the CPU?
:halt is op_31_0=0x05800000 {
	halt();
}

# Return from interrupt.
# FIXME: Properly implement returning from an interrupt (this is just a placeholder to make decompilation work).
:rti is op_31_0=0x05a00000 {
	return [pc];
}

# Software interrupt?
:swi #imm_15_0 is op_31_16=0x05c0 & imm_15_0 {
	swi(imm_15_0:2);
}

# Load byte from an offset relative to a register, zero extending.
:lbu rs1, #simm_19_8(rd) is op_31_20=0x060 & simm_19_8 & rs1 & rd {
	rs1 = zext(*[DMEM]:1 (rd + simm_19_8));
}

# Load half word from an offset relative to a register, zero extending.
:lhu rs1, #simm_19_8(rd) is op_31_20=0x061 & simm_19_8 & rs1 & rd {
	rs1 = zext(*[DMEM]:2 (rd + simm_19_8));
}

# Load byte from an offset relative to a register, sign extending.
:lb rs1, #simm_19_8(rd) is op_31_20=0x062 & simm_19_8 & rs1 & rd {
	rs1 = sext(*[DMEM]:1 (rd + simm_19_8));
}

# Load half word from an offset relative to a register, sign extending.
:lh rs1, #simm_19_8(rd) is op_31_20=0x063 & simm_19_8 & rs1 & rd {
	rs1 = sext(*[DMEM]:2 (rd + simm_19_8));
}

# Load word from an offset relative to a register.
:lw rs1, #simm_19_8(rd) is op_31_20=0x064 & simm_19_8 & rs1 & rd {
	rs1 = *[DMEM](rd + simm_19_8);
}

# Store byte at an offset relative to a register.
:sb rs1, #simm_19_8(rd) is op_31_20=0x065 & simm_19_8 & rs1 & rd {
	*[DMEM](rd + simm_19_8) = rs1:1;
}

# Store half word at an offset relative to a register.
:sh rs1, #simm_19_8(rd) is op_31_20=0x066 & simm_19_8 & rs1 & rd {
	*[DMEM](rd + simm_19_8) = rs1:2;
}

# Store word at an offset relative to a register.
:sw rs1, #simm_19_8(rd) is op_31_20=0x067 & simm_19_8 & rs1 & rd {
	*[DMEM](rd + simm_19_8) = rs1;
}

:lbu rs1, (rd+=#simm_19_8) is op_31_20=0x068 & simm_19_8 & rs1 & rd {
	rs1 = zext(*[DMEM]:1 (rd));
	rd = rd + simm_19_8;
}

:lhu rs1, (rd+=#simm_19_8) is op_31_20=0x069 & simm_19_8 & rs1 & rd {
	rs1 = zext(*[DMEM]:2 (rd));
	rd = rd + simm_19_8;
}

:lb rs1, (rd+=#simm_19_8) is op_31_20=0x06a & simm_19_8 & rs1 & rd {
	rs1 = sext(*[DMEM]:1 (rd));
	rd = rd + simm_19_8;
}

:lh rs1, (rd+=#simm_19_8) is op_31_20=0x06b & simm_19_8 & rs1 & rd {
	rs1 = sext(*[DMEM]:2 (rd));
	rd = rd + simm_19_8;
}

:lw rs1, (rd+=#simm_19_8) is op_31_20=0x06c & simm_19_8 & rs1 & rd {
	rs1 = *[DMEM](rd);
	rd = rd + simm_19_8;
}

:sb rs1, (rd+=#simm_19_8) is op_31_20=0x06d & simm_19_8 & rs1 & rd {
	*[DMEM](rd) = rs1:1;
	rd = rd + simm_19_8;
}

:sh rs1, (rd+=#simm_19_8) is op_31_20=0x06e & simm_19_8 & rs1 & rd {
	*[DMEM](rd) = rs1:2;
	rd = rd + simm_19_8;
}

:sw rs1, (rd+=#simm_19_8) is op_31_20=0x06f & simm_19_8 & rs1 & rd {
	*[DMEM](rd) = rs1;
	rd = rd + simm_19_8;
}

:rl rs1, rd is op_31_8=0x070000 & rs1 & rd unimpl
:cw rs1, rd is op_31_8=0x070001 & rs1 & rd unimpl

:ior rs1, #imm_12_8(rd) is op_31_13=0b0000011100000000010 & imm_12_8 & rs1 & rd {
	rs1 = ior(rd + imm_12_8);
}

:iow rs1, #imm_12_8(rd) is op_31_13=0b0000011100000000011 & imm_12_8 & rs1 & rd {
	iow(rd + imm_12_8, rs1);
}

# Move from dbg CSR to register.
:mv rd, dbg is op_31_4=0x0700800 & rd & dbg {
	rd = dbg;
}

# Move from register to dbg CSR.
:mv dbg, rd is op_31_4=0x0700801 & rd & dbg {
	dbg = rd;
}

:ieon is op_31_0=0x07008020 {
	ieon();
}

:ieoff is op_31_0=0x07008021 {
	ieoff();
}

# ADD a register with an immediate.
:add rd, rs1, #simm_23_8 is op_31_24=0x08 & simm_23_8 & rs1 & rd {
	rd = rs1 + simm_23_8;
}

# SUB a register with an immediate.
:sub rd, rs1, #simm_23_8 is op_31_24=0x09 & simm_23_8 & rs1 & rd {
	rd = rs1 - simm_23_8;
}

# Add with carry.
# TODO: Implement carry.
:addx rd, rs1, #simm_23_8 is op_31_24=0x0a & simm_23_8 & rs1 & rd {
	rd = rs1 + simm_23_8;
}

# Subtract with borrow.
# TODO: Implement borrow.
:subx rd, rs1, #simm_23_8 is op_31_24=0x0b & simm_23_8 & rs1 & rd {
	rd = rs1 - simm_23_8;
}

# AND a register with an immediate.
:and rd, rs1, #imm_23_8 is op_31_24=0x0c & imm_23_8 & rs1 & rd {
	rd = rs1 & imm_23_8;
}

# OR a register with an immediate.
:or rd, rs1, #imm_23_8 is op_31_24=0x0d & imm_23_8 & rs1 & rd {
	rd = rs1 | imm_23_8;
}

# XOR a register with an immediate.
:xor rd, rs1, #imm_23_8 is op_31_24=0x0e & imm_23_8 & rs1 & rd {
	rd = rs1 ^ imm_23_8;
}

# Set the high 16 bits of a register, clearing the lower bits.
:sethi rd, #imm_23_8 is op_31_24=0x0f & imm_23_8 & rs1=0 & rd {
	rd = imm_23_8 << 16;
}

:ble.d1 rs1, rd, #jump_dest is op_31_23=0b000100000 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local delayflag = (rs1 s<= rd);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:ble.d1 #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001000010 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (calc_imm:4 s<= r_8_5);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Branch if register less than or equal to immediate, signed, delayed by 1.
:ble.d1 r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001000011 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (r_8_5 s<= calc_imm:4);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:bleu.d1 rs1, rd, #jump_dest is op_31_23=0b000100010 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local delayflag = (rs1 <= rd);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:bleu.d1 #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001000110 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (calc_imm:4 <= r_8_5);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Branch if register less than or equal to immediate, signed, delayed by 1.
:bleu.d1 r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001000111 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (r_8_5 <= calc_imm:4);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:blt.d1 rs1, rd, #jump_dest is op_31_23=0b000100100 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local delayflag = (rs1 s< rd);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:blt.d1 #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001001010 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (calc_imm:4 s< r_8_5);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Branch if register less than immediate, signed, delayed by 1.
:blt.d1 r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001001011 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (r_8_5 s< calc_imm:4);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Branch if less-than, unsigned.
:bltu.d1 rs1, rd, #jump_dest is op_31_23=0b000100110 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local delayflag = (rs1 < rd);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:bltu.d1 #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001001110 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (calc_imm:4 < r_8_5);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:bltu.d1 r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001001111 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (r_8_5 < calc_imm:4);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:beq.d1 rs1, rd, #jump_dest is op_31_23=0b000101000 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local delayflag = (rs1 == rd);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:beq.d1 #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001010010 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (calc_imm:4 == r_8_5);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# FIXME: Handle nested loops.
# FIXME: See j16.d2.
:do.d2 #imm32_7_0, #loop_end is op_31_20=0x14c & imm_19_8 & imm32_7_0 [
	loop_end = inst_start + imm_19_8;
	end_of_loop = 1;
	globalset(loop_end, end_of_loop);
] {
	delayslot(4);
	ls0 = inst_next;
	lc0 = imm32_7_0;
	le0 = loop_end;
}

# FIXME: Handle nested loops.
# FIXME: See j16.d2.
:do.d2 rd, #loop_end is op_31_20=0x14e & imm_19_8 & rd [
	loop_end = inst_start + imm_19_8;
	end_of_loop = 1;
	globalset(loop_end, end_of_loop);
] {
	delayslot(4);
	ls0 = inst_next;
	lc0 = rd;
	le0 = loop_end;
}

:bne.d1 rs1, rd, #jump_dest is op_31_23=0b000101010 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local delayflag = (rs1 != rd);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

:bne.d1 #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001010110 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local delayflag = (calc_imm:4 != r_8_5);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Unconditional relative jump.
:j.d1 #jump_dest is op_31_21=0b00010110000 & simm_20_0 [
	jump_dest = inst_start + simm_20_0 * 2;
] {
	delayslot(2);
	goto [jump_dest:4];
}

# Unconditional relative jump with link.
:jal.d1 #jump_dest is op_31_21=0b00010111000 & simm_20_0 [
	jump_dest = inst_start + simm_20_0 * 2;
] {
	delayslot(2);
	r15 = inst_next;
	call [jump_dest:4];
}

:ble rs1, rd, #jump_dest is op_31_23=0b000110000 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local flag = (rs1 s<= rd);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:ble #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001100010 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (calc_imm:4 s<= r_8_5);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:ble r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001100011 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (r_8_5 s<= calc_imm:4);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:bleu rs1, rd, #jump_dest is op_31_23=0b000110010 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local flag = (rs1 <= rd);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:bleu #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001100110 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (calc_imm:4 <= r_8_5);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:bleu r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001100111 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (r_8_5 <= calc_imm:4);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:blt rs1, rd, #jump_dest is op_31_23=0b000110100 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local flag = (rs1 s< rd);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:blt #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001101010 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (calc_imm:4 s< r_8_5);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:blt r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001101011 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (r_8_5 s< calc_imm:4);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

# Branch if less-than, unsigned.
:bltu rs1, rd, #jump_dest is op_31_23=0b000110110 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	local flag = (rs1 < rd);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:bltu #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001101110 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (calc_imm:4 < r_8_5);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

:bltu r_8_5, #calc_imm, #jump_dest is op_31_22=0b0001101111 & imm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (imm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (r_8_5 < calc_imm:4);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

# Branch if registers are equal.
:beq rs1, rd, #jump_dest is op_31_23=0b000111000 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	if !(rs1 == rd) goto inst_next;
	goto [jump_dest:4];
}

# Branch if immediate equal to register.
:beq #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001110010 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (calc_imm:4 == r_8_5);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

# FIXME: Handle nested loops.
:do #imm32_7_0, #loop_end is op_31_20=0x1cc & imm_19_8 & imm32_7_0 [
	loop_end = inst_start + imm_19_8;
	end_of_loop = 1;
	globalset(loop_end, end_of_loop);
] {
	ls0 = inst_next;
	lc0 = imm32_7_0;
	le0 = loop_end;
}

# FIXME: Handle nested loops.
:do rd, #loop_end is op_31_20=0x1ce & imm_19_8 & rd [
	loop_end = inst_start + imm_19_8;
	end_of_loop = 1;
	globalset(loop_end, end_of_loop);
] {
	ls0 = inst_next;
	lc0 = rd;
	le0 = loop_end;
}

# Branch if registers are not equal.
:bne rs1, rd, #jump_dest is op_31_23=0b000111010 & simm_22_8 & rs1 & rd [
	jump_dest = inst_start + simm_22_8 * 2;
] {
	if !(rs1 != rd) goto inst_next;
	goto [jump_dest:4];
}

# Branch if immediate not equal to register.
:bne #calc_imm, r_8_5, #jump_dest is op_31_22=0b0001110110 & simm_21_18 & simm_17_9 & r_8_5 & imm_4_0 [
	calc_imm = (simm_21_18 << 5) | imm_4_0;
	jump_dest = inst_start + simm_17_9 * 2;
] {
	local flag = (calc_imm:4 != r_8_5);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

# Unconditional relative jump.
:j #jump_dest is op_31_21=0b00011110000 & simm_20_0 [
	jump_dest = inst_start + simm_20_0 * 2;
] {
	goto [jump_dest:4];
}

# Unconditional relative jump with link.
:jal #jump_dest is op_31_21=0b00011111000 & simm_20_0 [
	jump_dest = inst_start + simm_20_0 * 2;
] {
	r15 = inst_next;
	call [jump_dest:4];
}

# Unconditional absolute jump to register with link.
:jal rd is op_31_4=0x1f80000 & rd {
	r15 = inst_next;
	call [rd];
}

# Copy the (signed) max of the values of two registers into a register.
:max rd, rs1, rs2 is op_31_12=0x20000 & rs2 & rs1 & rd {
	if (rs1 s> rs2) goto <rs1_greater>;
	rd = rs2;
	goto <end>;
	<rs1_greater>
	rd = rs1;
	<end>
}

# Copy the (signed) min of the values of two registers into a register.
:min rd, rs1, rs2 is op_31_12=0x20001 & rs2 & rs1 & rd {
	if (rs1 s< rs2) goto <rs1_lesser>;
	rd = rs2;
	goto <end>;
	<rs1_lesser>
	rd = rs1;
	<end>
}

# ADD a register with a register and an immediate.
:add rd, rs1, #imm is op_31_13=0b0010000000000000001 & imm_12_12 & rs2 & rs1 & rd [
	imm = imm_12_12 + 1;
] {
	rd = rs1 + rs2 + imm;
}

# Max of two 16-bit integers in two registers.
:maxd rd, rs1, rs2 is op_31_12=0x20005 & rs2 & rs1 & rd {
	local rs1_lo:2 = rs1:2;
	local rs1_hi:2 = rs1(2);
	local rs2_lo:2 = rs2:2;
	local rs2_hi:2 = rs2(2);

	# Find the signed maximum of the lower halves of rs1 and rs2.
	if (rs1_lo s> rs2_lo) goto <rs1_low_greater>;
	rd = rs2 & 0xffff;
	goto <end_low>;
	<rs1_low_greater>
	rd = rs1 & 0xffff;
	<end_low>

	# Find the signed maximum of the upper halves of rs1 and rs2.
	if (rs1_hi s> rs2_hi) goto <rs1_high_greater>;
	rd = rd | (rs2 & 0xffff0000);
	goto <end_high>;
	<rs1_high_greater>
	rd = rd | (rs1 & 0xffff0000);
	<end_high>
}

# Min of two 16-bit integers in two registers.
:mind rd, rs1, rs2 is op_31_12=0x20007 & rs2 & rs1 & rd {
	local rs1_lo:2 = rs1:2;
	local rs1_hi:2 = rs1(2);
	local rs2_lo:2 = rs2:2;
	local rs2_hi:2 = rs2(2);

	# Find the signed minimum of the lower halves of rs1 and rs2.
	if (rs1_lo s< rs2_lo) goto <rs1_low_lesser>;
	rd = rs2 & 0xffff;
	goto <end_low>;
	<rs1_low_lesser>
	rd = rs1 & 0xffff;
	<end_low>

	# Find the signed minimum of the upper halves of rs1 and rs2.
	if (rs1_hi s< rs2_hi) goto <rs1_high_lesser>;
	rd = rd | (rs2 & 0xffff0000);
	goto <end_high>;
	<rs1_high_lesser>
	rd = rd | (rs1 & 0xffff0000);
	<end_high>
}

:osl rd, rs1, rs2, #imm_16_12 is op_31_17=0b001000000000001 & imm_16_12 & rs2 & rs1 & rd unimpl

:rnds rd, rs1, #imm_18_9 is op_31_19=0b0010000000001 & imm_18_9 & op_8_8=0 & rs1 & rd unimpl
:rndu rd, rs1, #imm_18_9 is op_31_19=0b0010000000001 & imm_18_9 & op_8_8=1 & rs1 & rd unimpl

:fup rd, rs1, #imm_17_13, #imm_12_8 is op_31_18=0b00100000000100 & imm_17_13 & imm_12_8 & rs1 & rd unimpl

:fxtu rd, rs1, #imm_18_14, #imm_13_9 is op_31_19=0b0010000000100 & imm_18_14 & imm_13_9 & op_8_8=0 & rs1 & rd unimpl
:fxts rd, rs1, #imm_18_14, #imm_13_9 is op_31_19=0b0010000000100 & imm_18_14 & imm_13_9 & op_8_8=1 & rs1 & rd unimpl

:fup rd, #imm_11_4, #imm_21_17, #imm_16_12 is op_31_22=0b0010000000 & imm_21_17 & imm_16_12 & imm_11_4 & rd unimpl

}


# Stand-alone 16-bit instructions (unbundled/unpaired only).

with: bundle=0 {

# 16-bit NOP.
:nop16 is op_15_0=0x8000 {}

# AND an unsigned immediate with a register between r1 and r8 to a register between r1 and r8.
with: op_15_9=0b1000000 {
	:and16 rn_r1_r8, rm_r1_r8_5_3, #mask is (op_8_6=1 | op_8_6=2 | op_8_6=3 | op_8_6=4) & op_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [ mask = (1 << op_8_6) - 1; ] { rn_r1_r8 = rm_r1_r8_5_3 & mask; }
	:and16 rn_r1_r8, rm_r1_r8_5_3, #mask is op_8_6=5 & rm_r1_r8_5_3 & rn_r1_r8 [ mask = 0xff; ] { rn_r1_r8 = rm_r1_r8_5_3 & mask; }
	:and16 rn_r1_r8, rm_r1_r8_5_3, #mask is op_8_6=6 & rm_r1_r8_5_3 & rn_r1_r8 [ mask = 0xff00; ] { rn_r1_r8 = rm_r1_r8_5_3 & mask; }
	:and16 rn_r1_r8, rm_r1_r8_5_3, #mask is op_8_6=7 & rm_r1_r8_5_3 & rn_r1_r8 [ mask = 0xffff; ] { rn_r1_r8 = rm_r1_r8_5_3 & mask; }
}

# Shift register left (logical) by an immediate.
:sll16 rn_r1_r8, rm_r1_r8_5_3, #imm_8_6 is op_15_9=0b1000001 & imm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 {
	rn_r1_r8 = rm_r1_r8_5_3 << imm_8_6;
}

# ADD two registers.
:add16 rn_r1_r8, rm_r1_r8_5_3, rm_r1_r8_8_6 is op_15_9=0b1000010 & rm_r1_r8_8_6 & rm_r1_r8_5_3 & rn_r1_r8 { rn_r1_r8 = rm_r1_r8_5_3 + rm_r1_r8_8_6; }

# Add a signed immediate to a register.
:add16 rn, #simm_8_4 is op_15_9=0b1000011 & simm_8_4 & rn {
	rn = rn + simm_8_4;
}

# ADD two registers.
:add16 rn, rm is op_15_8=0x88 & rm & rn { rn = rn + rm; }

# SUB two registers.
:sub16 rn, rm is op_15_8=0x89 & rm & rn { rn = rn - rm; }

# AND two registers.
:and16 rn, rm is op_15_8=0x8a & rm & rn { rn = rn & rm; }

# OR two registers.
:or16  rn, rm is op_15_8=0x8b & rm & rn { rn = rn | rm; }

# XOR two registers.
:xor16 rn, rm is op_15_8=0x8c & rm & rn { rn = rn ^ rm; }

# Count leading zeros. Starting from the most significant bit in rm, count the
# number of contiguous zero bits and store that count in rn.
:clz16 rn, rm is op_15_8=0x8d & rm & rn {
	rn = 0;
	if (rm & (1 << 31)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 30)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 29)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 28)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 27)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 26)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 25)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 24)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 23)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 22)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 21)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 20)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 19)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 18)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 17)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 16)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 15)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 14)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 13)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 12)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 11)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 10)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 9)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 8)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 7)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 6)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 5)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 4)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 3)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 2)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 1)) != 0 goto inst_next;
	rn = rn + 1;
	if (rm & (1 << 0)) != 0 goto inst_next;
	rn = rn + 1;
}

# Shift register right (arithmetic) by an immediate.
:sra16 rn, #imm_7_4 is op_15_8=0x90 & imm_7_4 & rn {
	rn = rn s>> imm_7_4;
}

# Shift register left by an immediate.
:sll16 rn, #imm_7_4 is op_15_8=0x91 & imm_7_4 & rn {
	rn = rn << imm_7_4;
}

# Add an unsigned immediate to the stack pointer.
:addsp16 r14, #offset is r14 & op_15_8=0x92 & imm_7_0 [
	offset = imm_7_0 * 4;
] {
	r14 = r14 + offset;
}

# Move data from register to register.
:mv16 rn, rm is op_15_8=0x93 & rm & rn {
	rn = rm;
}

# Add an unsigned immediate to the stack pointer and store it in a register.
:add16 rn, r14, #offset is r14 & op_15_10=0b100101 & imm_9_4 & rn [
	offset = -0x100 + imm_9_4 * 4;
] {
	rn = r14 + offset;
}

# Move immediate to register.
:mv16 rn, #simm_10_4 is op_15_11=0b10011 & simm_10_4 & rn {
	rn = simm_10_4;
}

:xtd16 rn_r1_r8, rm_r1_r8_5_3, #const is op_15_7=0b110000000 & imm_6_6 & rm_r1_r8_5_3 & rn_r1_r8 [ const = 8 + 8 * imm_6_6; ] unimpl

:mv16 a0l, rn_r1_r8 is op_15_3=0b1100000010000 & rn_r1_r8 & a0l { a0l = rn_r1_r8; }
:mv16 a0h, rn_r1_r8 is op_15_3=0b1100000010001 & rn_r1_r8 & a0h { a0h = rn_r1_r8; }
:mv16 rn_r1_r8, a0l is op_15_3=0b1100000010010 & rn_r1_r8 & a0l { rn_r1_r8 = a0l; }
:mv16 rn_r1_r8, a0h is op_15_3=0b1100000010011 & rn_r1_r8 & a0h { rn_r1_r8 = a0h; }

:mac16 rn, rm is op_15_8=0xc1 & rm & rn { a0 = a0 + (sext(rn) * sext(rm)); }

:maxv16 rn, rm is op_15_8=0xc2 & rm & rn unimpl
:minv16 rn, rm is op_15_8=0xc3 & rm & rn unimpl

:max16 rn, rm is op_15_8=0xc4 & rm & rn unimpl
:min16 rn, rm is op_15_8=0xc5 & rm & rn unimpl

:maxd16 rn, rm is op_15_8=0xc6 & rm & rn unimpl
:mind16 rn, rm is op_15_8=0xc7 & rm & rn unimpl

:mv16 csrn, rm_r1_r8_6_4 is op_15_7=0b110010000 & rm_r1_r8_6_4 & csrn { csrn = rm_r1_r8_6_4; }
:mv16 rn_r1_r8, csrm_6_3 is op_15_7=0b110010001 & csrm_6_3 & rn_r1_r8 { rn_r1_r8 = csrm_6_3; }

:bset16 rn_r1_r8, #imm_6_3 is op_15_7=0b110010010 & imm_6_3 & rn_r1_r8 unimpl
:bclr16 rn_r1_r8, #imm_6_3 is op_15_7=0b110010011 & imm_6_3 & rn_r1_r8 unimpl
:btgl16 rn_r1_r8, #imm_6_3 is op_15_7=0b110010100 & imm_6_3 & rn_r1_r8 unimpl

:rnds16 rn_r1_r8, rm_r1_r8_5_3, rm_r1_r8_8_6 is op_15_9=0b1100110 & rm_r1_r8_8_6 & rm_r1_r8_5_3 & rn_r1_r8 unimpl
:rndu16 rn_r1_r8, rm_r1_r8_5_3, rm_r1_r8_8_6 is op_15_9=0b1100111 & rm_r1_r8_8_6 & rm_r1_r8_5_3 & rn_r1_r8 unimpl

:osl16 rn_r1_r8, rm_r1_r8_5_3, #imm_9_6 is op_15_10=0b110100 & imm_9_6 & rm_r1_r8_5_3 & rn_r1_r8 unimpl

}


# 16-bit instructions that may either stand alone or be the second instruction in a bundle.

with: (bundle=0 & op_15_15=1) | bundle=1 {

# Another 16-bit NOP.
:nop16.l is op_14_0=0x2000 {}

# Unconditional absolute jump to register 15 (link register), delayed by 2.
# FIXME: See below.
:j16.d2 rn is op_14_4=0x202 & rn & rn=15 {
	delayslot(4);
	return [rn];
}

# Unconditional absolute jump to register, delayed by 2.
# FIXME: The "delayslot(4)" statement only covers half of the possibilities
# (a 2-byte instruction followed by either a 2-byte or 4-byte instruction),
# and does not handle the case where a 4-byte instruction is followed by
# either a 2-byte or 4-byte instruction.
:j16.d2 rn is op_14_4=0x202 & rn {
	delayslot(4);
	goto [rn];
}

# Unconditional absolute jump to register 15 (link register).
:j16 rn is op_14_4=0x203 & rn & rn=15 {
	return [rn];
}

# Unconditional absolute jump to register.
:j16 rn is op_14_4=0x203 & rn {
	goto [rn];
}

# Unconditional relative jump by immediate, delayed by 1.
:j16.d1 #jump_dest is op_14_7=0b01000010 & simm_6_0 [
	jump_dest = inst_start + simm_6_0 * 2;
] {
	delayslot(2);
	goto [jump_dest:4];
}

# Unconditional relative jump by immediate.
:j16 #jump_dest is op_14_7=0b01000011 & simm_6_0 [
	jump_dest = inst_start + simm_6_0 * 2;
] {
	goto [jump_dest:4];
}

# Load sign-extended half word relative to a register between r1 and r8.
:lh16 rn_r1_r8, #offset^(rm_r1_r8_5_3) is op_14_6=0b010001000 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = 0;
] {
	rn_r1_r8 = sext(*[DMEM]:2 (rm_r1_r8_5_3));
}

# Load zero-extended half word relative to a register between r1 and r8.
:lhu16 rn_r1_r8, #offset^(rm_r1_r8_5_3) is op_14_6=0b010001001 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = 0;
] {
	rn_r1_r8 = zext(*[DMEM]:2 (rm_r1_r8_5_3));
}

# Load sign-extended byte relative to a register between r1 and r8.
:lb16 rn_r1_r8, #offset^(rm_r1_r8_5_3) is op_14_6=0b010001010 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = 0;
] {
	rn_r1_r8 = sext(*[DMEM]:1 (rm_r1_r8_5_3));
}

# Load zero-extended byte relative to a register between r1 and r8.
:lbu16 rn_r1_r8, #offset^(rm_r1_r8_5_3) is op_14_6=0b010001011 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = 0;
] {
	rn_r1_r8 = zext(*[DMEM]:1 (rm_r1_r8_5_3));
}

# Store half word at an offset relative to a register between r1 and r8.
:sh16 rn, #offset^(rm_r1_r8_6_4) is op_14_7=0b01000110 & rm_r1_r8_6_4 & rn [
	offset = 0;
] {
	*[DMEM](rm_r1_r8_6_4 + offset) = rn:2;
}

# Store byte at an offset relative to a register between r1 and r8.
:sb16 rn, #offset^(rm_r1_r8_6_4) is op_14_7=0b01000111 & rm_r1_r8_6_4 & rn [
	offset = 0;
] {
	*[DMEM](rm_r1_r8_6_4 + offset) = rn:1;
}

# Load word from an offset relative to the stack pointer.
:lw16 rn, #offset^(r14) is r14 & op_14_9=0b010010 & imm_8_4 & rn [
	offset = -0x80 + imm_8_4 * 4;
] {
	rn = *[DMEM](r14 + offset);
}

# Store word at an offset relative to the stack pointer.
:sw16 rn, #offset^(r14) is r14 & op_14_9=0b010011 & imm_8_4 & rn [
	offset = -0x80 + imm_8_4 * 4;
] {
	*[DMEM](r14 + offset) = rn;
}

# Load word from an offset relative to a register between r1 and r8.
:lw16 rn, #offset^(rm_r1_r8_6_4) is op_14_10=0b01010 & imm_9_7 & rm_r1_r8_6_4 & rn [
	offset = imm_9_7 * 4;
] {
	rn = *[DMEM](rm_r1_r8_6_4 + offset);
}

# Store word at an offset relative to a register between r1 and r8.
:sw16 rn, #offset^(rm_r1_r8_6_4) is op_14_10=0b01011 & imm_9_7 & rm_r1_r8_6_4 & rn [
	offset = imm_9_7 * 4;
] {
	*[DMEM](rm_r1_r8_6_4 + offset) = rn;
}

# Load word from an address in a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:lw16 rn, (rm_r1_r8_6_4+=#offset) is op_14_10=0b01100 & simm_9_7 & rm_r1_r8_6_4 & rn [
	offset = simm_9_7 * 4;
] {
	rn = *[DMEM](rm_r1_r8_6_4);
	rm_r1_r8_6_4 = rm_r1_r8_6_4 + offset;
}

# Store word at an address in a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:sw16 rn, (rm_r1_r8_6_4+=#offset) is op_14_10=0b01101 & simm_9_7 & rm_r1_r8_6_4 & rn [
	offset = simm_9_7 * 4;
] {
	*[DMEM](rm_r1_r8_6_4) = rn;
	rm_r1_r8_6_4 = rm_r1_r8_6_4 + offset;
}

# Branch if register equal to zero, delayed by 1.
:beq16.d1 #zero, rn, #jump_dest is op_14_9=0b011100 & imm_8_4 & rn [
	zero = 0;
	jump_dest = inst_start + imm_8_4 * 2;
] {
	local delayflag = (0 == rn);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Branch if register not equal to zero, delayed by 1.
:bne16.d1 #zero, rn, #jump_dest is op_14_9=0b011101 & imm_8_4 & rn [
	zero = 0;
	jump_dest = inst_start + imm_8_4 * 2;
] {
	local delayflag = (0 != rn);
	delayslot(2);
	if !delayflag goto inst_next;
	goto [jump_dest:4];
}

# Branch if register equal to zero.
:beq16 #zero, rn, #jump_dest is op_14_9=0b011110 & imm_8_4 & rn [
	zero = 0;
	jump_dest = inst_start + imm_8_4 * 2;
] {
	local flag = (0 == rn);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

# Branch if register not equal to zero.
:bne16 #zero, rn, #jump_dest is op_14_9=0b011111 & imm_8_4 & rn [
	zero = 0;
	jump_dest = inst_start + imm_8_4 * 2;
] {
	local flag = (0 != rn);
	if !flag goto inst_next;
	goto [jump_dest:4];
}

# Load sign-extended half word relative to a register between r1 and r8.
:lh16 rn_r1_r8, #offset^(rm_r1_r8_5_3) is op_14_9=0b110000 & simm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = simm_8_6 * 2;
] {
	rn_r1_r8 = sext(*[DMEM]:2 (rm_r1_r8_5_3 + offset));
}

# Load zero-extended half word relative to a register between r1 and r8.
:lhu16 rn_r1_r8, #offset^(rm_r1_r8_5_3) is op_14_9=0b110001 & simm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = simm_8_6 * 2;
] {
	rn_r1_r8 = zext(*[DMEM]:2 (rm_r1_r8_5_3 + offset));
}

# Store half word at an offset relative to a register between r1 and r8.
:sh16 rn, #offset^(rm_r1_r8_6_4) is op_14_10=0b11001 & simm_9_7 & rm_r1_r8_6_4 & rn [
	offset = simm_9_7 * 2;
] {
	*[DMEM](rm_r1_r8_6_4 + offset) = rn:2;
}

# Store half word at an address in a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:sh16 rm_6_3, (rn_r1_r8+=#offset) is op_14_10=0b11010 & simm_9_7 & rm_6_3 & rn_r1_r8 [
	offset = simm_9_7 * 2;
] {
	*[DMEM](rn_r1_r8) = rm_6_3:2;
	rn_r1_r8 = rn_r1_r8 + offset;
}

# Load sign-extended half word relative to a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:lh16 rn_r1_r8, (rm_r1_r8_5_3+=#offset) is op_14_9=0b110110 & simm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = simm_8_6 * 2;
] {
	rn_r1_r8 = sext(*[DMEM]:2 (rm_r1_r8_5_3));
	rm_r1_r8_5_3 = rm_r1_r8_5_3 + offset;
}

# Load zero-extended half word relative to a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:lhu16 rn_r1_r8, (rm_r1_r8_5_3+=#offset) is op_14_9=0b110111 & simm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = simm_8_6 * 2;
] {
	rn_r1_r8 = zext(*[DMEM]:2 (rm_r1_r8_5_3));
	rm_r1_r8_5_3 = rm_r1_r8_5_3 + offset;
}

# Move data from register to register.
:mv16.l rn, rm is op_14_8=0x70 & rm & rn {
	rn = rm;
}

# Store byte at an address in a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:sb16 rm_6_3, (rn_r1_r8+=#offset) is op_14_10=0b11110 & simm_9_7 & rm_6_3 & rn_r1_r8 [
	offset = simm_9_7 * 1;
] {
	*[DMEM](rn_r1_r8) = rm_6_3:1;
	rn_r1_r8 = rn_r1_r8 + offset;
}

# Load sign-extended byte relative to a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:lb16 rn_r1_r8, (rm_r1_r8_5_3+=#offset) is op_14_9=0b111110 & simm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = simm_8_6 * 1;
] {
	rn_r1_r8 = sext(*[DMEM]:1 (rm_r1_r8_5_3));
	rm_r1_r8_5_3 = rm_r1_r8_5_3 + offset;
}

# Load zero-extended byte relative to a register between r1 and r8, then offset the address in that register.
# TODO: Confirm the semantics of this instruction on hardware.
:lbu16 rn_r1_r8, (rm_r1_r8_5_3+=#offset) is op_14_9=0b111111 & simm_8_6 & rm_r1_r8_5_3 & rn_r1_r8 [
	offset = simm_8_6 * 1;
] {
	rn_r1_r8 = zext(*[DMEM]:1 (rm_r1_r8_5_3));
	rm_r1_r8_5_3 = rm_r1_r8_5_3 + offset;
}

}


# 16-bit instruction bundles/pairs, prefix instructions.

with: bundle=0 {

# 16-bit NOP.
:nop16 is op_15_0=0x4000 [ bundle = 1; globalset(inst_next, bundle); ] {}

:mv16 rn_odd, rm_6_3 is op_15_7=0b010010011 & rm_6_3 & rn_odd [
	bundle = 1;
	globalset(inst_next, bundle);
] {
	rn_odd = rm_6_3;
}

# Add stack pointer to immediate and store in register.
:add16 rn_even, r14, #calc_imm is r14 & op_15_9=0b0100101 & imm_8_3 & rn_even [
	calc_imm = -0x100 | (imm_8_3 << 2);
	bundle = 1;
	globalset(inst_next, bundle);
] {
	rn_even = r14 + calc_imm:4;
}

}


# 16-bit instruction bundles/pairs, postfix instructions.

with: bundle=1 {

}


}
