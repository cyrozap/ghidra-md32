define endian=big;
define alignment=2;

define space PMEM type=ram_space size=4 default;
define space DMEM type=ram_space size=4;
define space register type=register_space size=4;

define register offset=0 size=4 [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
];

define register offset=0x1000 size=4 pc;

define token instr32(32)
	op_31_25 = (25, 31)
	op_31_24 = (24, 31)
	op_31_21 = (21, 31)
	op_31_20 = (20, 31)
	op_31_4 = (4, 31)
	imm_23_8 = (8, 23)
	simm_24_4 = (4, 24) signed
	simm_20_0 = (0, 20) signed
	simm_19_8 = (8, 19) signed
	rs1 = (4, 7)
	rd = (0, 3)
;

define token instr16(16)
	op_15_10 = (10, 15)
	op_15_9 = (9, 15)
	op_15_8 = (8, 15)
	op_15_4 = (4, 15)
	imm_9_7 = (7, 9)
	imm_9_4 = (4, 9)
	imm_8_4 = (4, 8)
	imm_7_0 = (0, 7)
	simm_8_4 = (4, 8) signed
	rm_r1_r8 = (4, 6)
	rm = (4, 7)
	rn = (0, 3)
;

attach variables [ rd rs1 rn rm ] [
	r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
];

attach variables [ rm_r1_r8 ] [
	r1 r2 r3 r4 r5 r6 r7 r8
];


# 32-bit instructions

# Move signed immediate to register.
:mv rd, simm_24_4 is op_31_25=0 & simm_24_4 & rd {
	rd = simm_24_4;
}

# OR a register with an immediate.
:or rd, rs1, imm_23_8 is op_31_24=0x0d & imm_23_8 & rs1 & rd {
	rd = rs1 | imm_23_8;
}

# Set the high 16 bits of a register, clearing the lower bits.
:sethi rd, imm_23_8 is op_31_24=0x0f & imm_23_8 & rs1=0 & rd {
	rd = imm_23_8 << 16;
}

# Unconditional relative jump.
:j jump_dest is op_31_21=0b00011110000 & simm_20_0 [
	jump_dest = inst_start + simm_20_0 * 2;
] {
	goto [jump_dest:4];
}

# Unconditional relative jump with link.
:jal jump_dest is op_31_21=0b00011111000 & simm_20_0 [
	jump_dest = inst_start + simm_20_0 * 2;
] {
	r15 = inst_next;
	call [jump_dest:4];
}

# Unconditional absolute jump to register with link.
:jal rd is op_31_4=0x1f80000 & rd {
	r15 = inst_next;
	call [rd];
}

# Store half word at an offset relative to a register.
:sh rs1, simm_19_8(rd) is op_31_20=0x066 & simm_19_8 & rs1 & rd {
	*[DMEM](rd + simm_19_8) = rs1:2;
}

# Store word at an offset relative to a register.
:sw rs1, simm_19_8(rd) is op_31_20=0x067 & simm_19_8 & rs1 & rd {
	*[DMEM](rd + simm_19_8) = rs1;
}


# Stand-alone 16-bit instructions.

# Add a signed immediate to a register.
:add16 rn, simm_8_4 is op_15_9=0b1000011 & simm_8_4 & rn {
	rn = rn + simm_8_4;
}

# Add an unsigned immediate to the stack pointer and store it in a register.
:add16 rn, "r14", offset is op_15_10=0b100101 & imm_9_4 & rn [
	offset = -0x100 + imm_9_4 * 4;
] {
	rn = r14 + offset;
}

# Add an unsigned immediate to the stack pointer.
:addsp16 "r14", offset is op_15_8=0x92 & imm_7_0 [
	offset = imm_7_0 * 4;
] {
	r14 = r14 + offset;
}

# Unconditional absolute jump to register 15 (link register).
:j16 rn is op_15_4=0xa03 & rn & rn=15 {
	return [rn];
}

# Unconditional absolute jump to register.
:j16 rn is op_15_4=0xa03 & rn {
	goto [rn];
}

# Move data from register to register.
:mv16 rn, rm is op_15_8=0x93 & rm & rn {
	rn = rm;
}

# Load word from an offset relative to a register between r1 and r8.
:lw16 rn, offset^(rm_r1_r8) is op_15_10=0b101010 & imm_9_7 & rm_r1_r8 & rn [
	offset = imm_9_7 * 4;
] {
	rn = *[DMEM](rm_r1_r8 + offset);
}

# Load word from an offset relative to the stack pointer.
:lw16 rn, offset^("r14") is op_15_9=0b1010010 & imm_8_4 & rn [
	offset = -0x80 + imm_8_4 * 4;
] {
	rn = *[DMEM](r14 + offset);
}

# Store word at an offset relative to a register between r1 and r8.
:sw16 rn, offset^(rm_r1_r8) is op_15_10=0b101011 & imm_9_7 & rm_r1_r8 & rn [
	offset = imm_9_7 * 4;
] {
	*[DMEM](rm_r1_r8 + offset) = rn;
}

# Store word at an offset relative to the stack pointer.
:sw16 rn, offset^("r14") is op_15_9=0b1010011 & imm_8_4 & rn [
	offset = -0x80 + imm_8_4 * 4;
] {
	*[DMEM](r14 + offset) = rn;
}
